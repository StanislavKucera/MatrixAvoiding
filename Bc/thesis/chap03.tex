\chapter{An algorithm for testing pattern-avoidance of a special pattern}
\label{chap:walking}
In the previous chapter, we have seen an algorithm for a general forbidden patter. In this chapter, we introduce a special kind of a pattern, satisfying additional conditions, for which we can produce a much faster algorithm.

\section{Walking pattern}
We call the specific pattern a walking pattern. The additional condition we want the pattern to satisfy is that there is a walk from one corner to the opposite one and all the one-entries of the pattern are contained on the walk.
\paragraph{Definition}
A \textbf{walk} in a matrix is a sequence of some of its entries beginning in the top left corner and ending in the bottom right one. If an entry at the position $[i,j]$ is in the sequence, the next one is either $[i+1,j]$ or $[i,j+1]$. Therefore, the length of an arbitrary walk is equal to $w+h-1$ and we denote elements of the sequence by $e_1,e_2,\cdots,e_{w+h-1}$.
\begin{figure}[h!]
\centering
\includegraphics[width=90mm]{../img/walk.pdf}
\caption{An example of a walk and the order of its entries.}
\label{walk}
\end{figure}
%\centerline{\mbox{\includegraphics[width=75mm]{../img/walk.pdf}}}

In Figure \ref{walk} matrix $M$ is a walking pattern as all the one-entries are included in a walk. We can also see that not all entries of a walk need to be one-entries.

It can be shown a walking pattern is exactly a matrix avoiding a forbidden pattern
$$\left(\begin{array}{cc}
0 & 1 \\
1 & 0
\end{array}\right)$$

\section{Dynamic program}
Next, we show an algorithm deciding whether a \textbf{walking} pattern $P$ is contained in a big matrix $M$ or not.

The pattern $P$ is a walking pattern, so there is a walk containing all the one-entries of $P$. We choose one such walk arbitrarily. For each entry of the walk we remember whether its value in $P$ is one or zero and whether the walk continues from the entry vertically, in which case we call it a \emph{vertical entry} or horizontally, calling it a \emph{horizontal entry}.
\begin{defn}
For an element $e$ of $M$ at the position $[i,j]$, the matrix $M_{\leq e}$ is a $(i+1)\times(j+1)$ submatrix of $M$ consisting of rows with the index smaller than or equal to $i$ and columns with the index smaller than or equal to $j$. The element $e$ then lies in the bottom right corner. Similarly, $M_{\geq e}$ is a $(n-i)\times(n-j)$ submatrix of $M$ consisting of rows with the index greater than or equal to $i$ and columns with index greater then or equal to $j$. The element $e$ is its first element.
\end{defn}
To determine whether $P$ is contained in $M$ we find out for each element $e$ of $M$ what is the longest part of $P$ that can be found in $M_{\leq e}$. If there is an element for which we manage to find the whole pattern, $P$ is contained in $M$; otherwise, it is avoided.

\subsection{Inner structures}
To run properly, the algorithm needs two structures. The first one is a description of the walk, which is an array of the values of its entries (zero or one) and the information whether the entry is vertical or horizontal. The second structure is a matrix of the same size as $M$. For each element $e$ of $M$ at the position $[i,j]$ we remember two numbers. The number $c_v(e)$ says what is the longest part of the walk in $M_{\leq e}$ with the last entry in $j$-th column and being a vertical entry. The number $c_h(e)$, symmetrically, says what is the longest part of the walk in $M_{\leq e}$ with the last entry in $i$-th row and and being a horizontal entry.

\subsection{The algorithm}
An observation we make is that if we have an element $e$ of $M$ and any element $e'$ above $e$ in the same column, then $c_v(e')$ is less than or equal to $c_v(e)$. This means that we can always copy to value from the value of the element right above $e$ (at the position $[i-1,j]$) to get a lower bound of actual $c_v(e)$. Similarly the argument goes for the value of $c_h(e)$ in horizontal way.

The algorithm iterates through diagonals. 
\begin{defn}
A \emph{diagonal} of matrix $M$ is a subset of elements of $M$, such that all elements have the same sum of their coordinates.
\end{defn}
For example, zero diagonal only consists of an element $[0,0]$, the first diagonal contains elements $[0,1]$ and $[1,0]$, and so on.
\begin{figure}[h!]
\centering
\includegraphics[width=60mm]{../img/walking_alg.pdf}
\caption{Diagonals of an matrix and the order in which the algorithm for walking pattern iterates through them.}
\end{figure}
%\centerline{\mbox{\includegraphics[width=60mm]{../img/walking_alg.pdf}}}

For simplicity, in the pseudo-code below we do not deal with elements outside $M$ (like $-1,0$) explicitly. Instead, for those elements, we assume the values of $c_v$ and $c_h$ are always equal to zero.

The algorithm goes as follows:
\begin{enumerate}
\item For $d=0,\cdots,w+h-1$
\item \hspace{5mm} For $e$ element of $d$-th diagonal at the position $[i,j]$
\item \hspace{1cm} $e_v:=[i-1,j]$
\item \hspace{1cm} $e_h:=[i,j-1]$
\item \hspace{1cm} $c_v(e):=c_v(e_v)$
\item \hspace{1cm} $c_h(e):=c_h(e_h)$
\item \hspace{1cm} If $w_{c_v(e)+1}$ can be mapped to $e$
\item \hspace{15mm} If $c_v(e)+1=w+h+1$
\item \hspace{2cm} Terminate - $M$ contains $P$ as a submatrix
\item \hspace{15mm} If $w_{c_v(e)+1}$ is a vertical entry
\item \hspace{2cm} $c_v(e):=c_v(e)+1$
\item \hspace{15mm} Else
\item \hspace{2cm} $c_h(e):=max\{c_h(e),c_v(e)+1\}$
\item \hspace{1cm} If $w_{c_h(e)+1}$ can be mapped to $e$
\item \hspace{15mm} If $c_h(e)+1=w+h+1$
\item \hspace{2cm} Terminate - $M$ contains $P$ as a submatrix
\item \hspace{15mm} If $w_{c_h(e)+1}$ is a vertical entry
\item \hspace{2cm} $c_v(e):=max\{c_v(e),c_h(e)+1\}$
\item \hspace{15mm} Else
\item \hspace{2cm} $c_h(e):=max\{c_h(e),c_h(e)+1\}$
\end{enumerate}

\subsection{Correctness}
Note that the function can terminate before recomputing all elements and we have no guarantee about the state of elements, which have not been recomputed. If the function finds the pattern ending in entry $e$, it stops computing at that point, but to prove correctness it is enough to prove the values are correct in $M_{\leq e}$. If the function does not find the pattern, it recomputes the whole structure.

We need to show that the values of $c_v$ and $c_h$ are always correct for the recomputed elements at the end of the function. We proceed by induction.

For the first element it is definitely true since there can be only the first entry of the pattern mapped and we check just that.

When we compute an element $e$ of a computed diagonal $d$, by induction assumption all the diagonals $d'<d$ are correctly computed. In particular, the values are correct in the diagonal $d-1$. To compute the correct values of $e$, we use the values of two element on the diagonal $d-1$: $e_v$, which is right above $e$ and $e_h$, which is the first element to the left of $e$. If $e_v$ or $e_h$ are outside the matrix then from that direction we cannot expect to find anything more than just the first entry of the pattern and that is what we check for.

Let $v$ be the true length of the longest part of $P$ in $M_{\leq e}$ continuing vertically in the same column as $e$. Now if $e$ itself is not an entry of that part of the pattern, it is a different element $e'$ in the same column. But then the value of $c_v(e')$ is correctly computed by the inductive hypothesis and it is copied to all element underneath. Especially $e_v$ gets the value and the algorithm copies the value from it to $e$. On the other hand if $e$ is an entry of the part of the pattern we work with, it is the last entry. The entry right before the last one needs to be mapped to the same row or column; therefore, either $e_v$ or $e_h$ contain the part of the pattern shorter by one and the algorithm extends it to a correct value.

\subsection{Generalization}
The same algorithm, just rotated by 90 degrees, can be also used for a pattern where all one-entries are contained on a walk from top right corner to the bottom left one. Indeed the program uses it and if given a walking pattern it determines by itself which walk it is.

On the other hand a direct generalization for a general pattern does not work. While we can index all entries of the pattern, when trying to map a certain $w_k$ to an element it is not sufficient to just check whether $w_l$ is above and $w_l'$ to the left from the element.

\centerline{\mbox{\includegraphics[width=75mm]{../img/nogeneral.pdf}}}

In the picture, let the matrix on the left side be the pattern $P$ and let $M$ be the other matrix. The entry in the square can be mapped to the element in the square and the same holds for entries in the circle but it is not a sufficient condition for the entry in the triangle to be mapped to the element in the triangle.